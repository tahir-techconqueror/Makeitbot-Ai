
import { createServerClient } from '@/firebase/server-client';

export interface StatePageData {
    name: string;
    slug: string;
    dispensaryCount: number;
    topCities: Array<{ name: string; slug: string; count: number }>;
}

export async function fetchStatePageData(stateSlug: string) {
    const { firestore } = await createServerClient();

    let stateData: StatePageData | null = null;

    // 1. Fetch State config
    const stateDoc = await firestore.collection('foot_traffic')
        .doc('config')
        .collection('state_pages')
        .doc(stateSlug)
        .get();

    if (stateDoc.exists) {
        stateData = { ...stateDoc.data() } as StatePageData;
    } else {
        // Fallback? State pages should be pre-generated by config. 
        // If not, return null effectively 404ing or we handle "unknown state"
        return null;
    }

    // 2. Fetch Cities in this State
    // Used to populate "Top Cities" links
    // We expect city_pages to have a 'state' field matching stateData.name
    const citiesQuery = await firestore.collection('foot_traffic')
        .doc('config')
        .collection('city_pages')
        .where('state', '==', stateData.name)
        .orderBy('dispensaryCount', 'desc')
        .limit(20)
        .get();

    const topCities = citiesQuery.docs.map(doc => ({
        name: doc.data().name as string,
        slug: doc.data().slug as string,
        count: doc.data().dispensaryCount as number
    }));

    // Update local object with fresh topCities (overwriting whatever might be in doc if needed, or just appending)
    stateData.topCities = topCities;

    // Recalculate total count if needed, or trust the doc
    // stateData.dispensaryCount = topCities.reduce((sum, c) => sum + c.count, 0); // Approx if limited

    return stateData;
}
