
import { optimizePageContent, batchOptimizePages } from '@/server/actions/dayday-seo-content';
import { createServerClient } from '@/firebase/server-client';
import { ai } from '@/ai/genkit';
// import { gemini25Flash } from '@genkit-ai/vertexai'; // Removed to avoid ESM issues, using mock from config

// Mock dependencies
jest.mock('@/firebase/server-client', () => ({
    createServerClient: jest.fn()
}));

// ai usage is mocked via tests/__mocks__/genkit.ts (mapped in jest.config.js)
// BUT we also mock it here to control behavior for this test?
// If we mock it here, it overrides the global mock.
jest.mock('@/ai/genkit', () => ({
    ai: {
        generate: jest.fn()
    }
}));

// VertexAI mocked via moduleNameMapper in jest.config.js -> tests/__mocks__/genkit-vertexai.js
// So usage in SUT resolves to that mock.
// We don't need to mock it again here.

describe('Rise SEO Content Actions', () => {
    let mockFirestore: any;
    let mockCollection: any;
    let mockDoc: any;

    beforeEach(() => {
        jest.clearAllMocks();

        // Setup Firestore Mocks
        mockDoc = {
            exists: true,
            id: 'test_page_id',
            data: jest.fn().mockReturnValue({
                zipCode: '90210',
                city: 'Beverly Hills',
                state: 'CA',
                dispensaryCount: 5,
                dispensaryName: 'Test Dispensary',
                brandName: 'Test Brand'
            }),
            update: jest.fn().mockResolvedValue(true),
            get: jest.fn().mockResolvedValue({
                exists: true,
                data: () => ({ /* ... */ })
            }),
            collection: jest.fn() // Will be assigned below to handle circular ref
        };
        const mockSnapshot = {
            exists: true,
            data: mockDoc.data,
            id: mockDoc.id
        };
        mockDoc.get.mockResolvedValue(mockSnapshot);

        mockCollection = {
            doc: jest.fn(() => mockDoc),
            where: jest.fn().mockReturnThis(),
            limit: jest.fn().mockReturnThis(),
            get: jest.fn().mockResolvedValue({
                docs: [mockDoc]
            })
        };

        const mockSubCollection = {
            where: jest.fn().mockReturnThis(),
            limit: jest.fn().mockReturnThis(),
            get: jest.fn().mockResolvedValue({ docs: [mockDoc] })
        };

        mockFirestore = {
            collection: jest.fn(() => mockCollection),
            doc: jest.fn(() => mockDoc)
        };
        
        // Fix: collection() on a doc should return a collection-like object
        mockDoc.collection.mockReturnValue(mockSubCollection);

        (createServerClient as jest.Mock).mockResolvedValue({ firestore: mockFirestore });

        // Setup AI Mock default
        (ai.generate as jest.Mock).mockResolvedValue({
            text: 'AI Generated Text content.'
        });
    });

    describe('optimizePageContent', () => {
        it('should generate content for ZIP page correctly', async () => {
            (ai.generate as jest.Mock)
                .mockResolvedValueOnce({ text: 'Intro paragraph generated by AI.' })
                .mockResolvedValueOnce({ text: '[{"q": "Q1", "a": "A1"}]' });

            const result = await optimizePageContent('zip_90210', 'zip');

            expect(result.success).toBe(true);
            expect(result.intro).toBe('Intro paragraph generated by AI.');
            expect(result.faqs).toHaveLength(1);
            
            // Verify AI Interaction
            expect(ai.generate).toHaveBeenCalledTimes(2);
            // We verify model matches the mock structure from genkit-vertexai.js
            expect(ai.generate).toHaveBeenCalledWith(expect.objectContaining({
                model: 'vertexai/gemini-3.0-flash-001'
            }));
        });

        it('should handle missing page gracefully', async () => {
            mockDoc.get.mockResolvedValueOnce({ exists: false });
            
            const result = await optimizePageContent('missing_id', 'dispensary');
            
            expect(result.success).toBe(false);
            expect(mockDoc.update).not.toHaveBeenCalled();
        });
    });

    describe('batchOptimizePages', () => {
        it('should process multiple pages', async () => {
            const doc1 = { ...mockDoc, id: 'page_1' };
            const doc2 = { ...mockDoc, id: 'page_2' };
            
            mockCollection.get.mockResolvedValue({ docs: [doc1, doc2] });

            const result = await batchOptimizePages('zip', 10);

            expect(result.optimized).toBe(2);
            expect(result.errors).toBe(0);
        });
    });
});

